---
title: "Project Learning Diary - a performance analysis project"
date: "2017-04-01"
slug: "wps-project-summary"
---


In my final project at my internship, let's call it WPS, I worked on a performance analysis platform tailored for H5 pages. The primary technology stack included React, Redux, Webpack, and Ant Design. The frontend was developed using the dva framework, while the backend utilized the Egg.js framework. Although the project presented numerous challenges, I am grateful for the opportunity to work on it as it allowed me to learn performance analysis techniques and gain knowledge of the inner workings of certain technologies. Additionally, I appreciate having a mentor during my internship who patiently guided me on how to learn and grow. As I conclude my time here, I'd like to share some insights gained from the refactoring work done in the last month.

## Performance Analysis and Optimization in React Applications

While React addresses automatic UI refresh on state changes and the virtual DOM (diffing algorithm) reduces the cost of rendering to some extent, React isn't infallible. Firstly, comparing virtual DOMs incurs its own cost, and secondly, React may trigger renders in unexpected situations.

React calls the `shouldComponentUpdate(nextProps, nextState)` function in the lifecycle of each component. If this function returns true, indicating an update is necessary, a new virtual DOM is generated through render; if it returns false, no update occurs. By default, React always performs virtual DOM comparison, even if `shouldComponentUpdate` isn't explicitly defined.

In summary, there are two entry points for optimizing React applications:

- Reduce unnecessary render calls.
- Minimize the cost of virtual DOM comparison.

### Performance Analysis Tools

React provides `React.addons.Perf` to help analyze component performance.

- Before the operation, call `React.addons.Perf.start()`.
- After the operation, call `React.addons.Perf.stop()`.
- `printWasted()`: Useful for identifying wasted renders, where the virtual DOM remains unchanged but comparison still occurs.
- `printInclusive()`: Shows the total time spent by a component, aiding in identifying performance bottlenecks.
- To inspect React's DOM operations, use `React.addons.Perf.printDOM()`.

For more APIs, refer to the [React documentation](https://facebook.github.io/react/docs/perf.html).

### Performance Optimization

**Practical Scenario - Reducing Unnecessary React Renders**
Initially, when refactoring WPS, it was noticed that creating analysis module forms resulted in significant lag. While my colleague optimized the `shouldComponentUpdate` method of the `AnalyseRule` component, improving form responsiveness, revisiting the approach was necessary.
The following is a snapshot of the render activity of an unchanged input field within the rule of an analysis module, without any optimization:
[![Bad Rendering](http://ww1.sinaimg.cn/large/63739cabgy1fe607m1ezyj205x0a5jrc.jpg)](http://ww1.sinaimg.cn/large/63739cabgy1fe607m1ezyj205x0a5jrc.jpg)

When editing a rule, it was noticed that all rules, innocent of any changes, were also re-rendered along with the modified rule. To prevent this, the `shouldComponentUpdate` method of `AnalyseRule` and `ConditionItem` components was overridden to ensure that only the modified rule caused a render. This approach significantly reduced render times and DOM operations:
[![Improved Rendering](http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/d5d0376b3f838f21c77939d6d64fdbec/2017-03-31_144443.png)](http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/d5d0376b3f838f21c77939d6d64fdbec/2017-03-31_144443.png)

**About Immutable**
The `shouldComponentUpdate` method utilizes immutable data for comparison. Without immutable data, deep comparison is costly. Immutable data structures, by persisting data, reduce the cost of deep comparison and offer efficient methods like `is` to check for data changes.

In conclusion, best practices for React development include:

- Even for components with minimal reusability, avoid composing complex components within a single component.
- Keep props and state as simple and flat as possible.
- Avoid overuse of `{...this.props}`; only pass the necessary data to components to reduce the burden on `shouldComponentUpdate`.
- Use keys when mapping components to ensure efficient rendering.
- [More on the importance of keys in React](http://taobaofed.org/blog/2016/08/24/react-key/).
- [Understanding the impact of React Keys on rendering using Perf](http://levy.work/2016-08-31-debug-react-key-with-performance-tool/).

## Product Design and User Experience

As WPS lacked dedicated product managers, development tasks were handled by the development team, including product design considerations.

### Forms

Given the system's nature resembling a management dashboard, users interacted frequently with form inputs (e.g., creating analysis modules, generating evaluation reports). Optimizing form interactions involved:

- Providing clear user prompts and feedback, reducing user submission errors (e.g., placeholders, Ant Design's `hasFeedback` feature).
- Pre-filling input fields, enabling autofill and autocomplete to reduce user input time.

Other business-related considerations:

- When editing analysis modules, some included associated rules, while others did not. Differentiating between the two types improved editing efficiency and user experience.

### Task Waiting

Apart from form interactions, another crucial user scenario was waiting for analysis reports. Initially, users had to manually refresh to check for updated report statuses. Subsequently, an automatic refresh mechanism was implemented, improving user experience by reducing unnecessary user actions.

In conclusion, optimizing user experience revolves around making the product user-friendly (easy to use, minimizing frustration) and practical (efficient operations and usage). Ultimately, learn to think from the user's perspective and strive for "don’t make me think, don’t make me uncomfortable."

## Testing

Insufficient testing led to several issues during development. Testing isn't straightforward, but it follows a structured approach, starting with clear test cases.

**Test Case Design Methods**

- Black-box Testing (commonly used methods include equivalence partitioning and boundary value analysis).
- White-box Testing (suited for developers, including methods like statement coverage, decision coverage, and condition coverage).

In conclusion, testing requires meticulousness. While manual testing may overlook some issues, learning automated testing is valuable.

